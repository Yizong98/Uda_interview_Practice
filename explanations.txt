Question1:
Two strings are checked whether to be anagram through the counting of all characters of both string. Since we use t to check against s, anything that exists in t but doesn't exist in s or t has the same letter but more occurences should be a sign to return False. We do this through and loop and if anything goes well, it will return True. The runtime complexity here is O(n). The space complexity is O(1) since number of characters are bounded. 
Question2:
We iterate every possible substring through a nested loop  and checks whether it is the same read backwards. If it is, we store in the list of substring that stores palindrome. Then we return the string with max length in the list. Time complexity is O(n^2). The space complexity is O(n) because we store a list of data and filter at the end.
Question3:
Kruskal's algorithm is used to solve this problem. We sort edges by weights and use sets to prevent cycles. Firstly, generate a list of edges take O(n) time and O(n) space. Then we sort the edges by weights, taking O(nlog(n)) time and O(n)space. After that we loop through each edge, search for index and take union of sets. The worst case is O(n^2) and O(n) space. Finally we process the edges to graph. The whole algorithm takes O(n^2) time and O(n) space.
Question4:
First we design a helper method to get a list of child, which has time complexity O(n) and space O(n). Then we use loop to check the value against left child and right child. If the root index is bigger than the two nodes, we go to check the left node. If smaller than the two nodes, we go to check the right node. Else the root stay the same as LCA. The Time complexity on average is O(log(n)). The space complexity is O(n) since we need to store the tree.
Question5:
First we design a helper function to find length of the linkedlist, which takes O(n) time. We only have to check one node at a time, so the space complexity is O(1). The finding function(question5) takes in a linkedlist, use the helper function to get the length, then use a loop to iterate through the length of the linkedlist minus the last m times, which gives the position of the wanted element. We return the element's data for the output. The time complexity of the finding function is O(n). The space is also O(1), since we only store one node at a time.